## 贪婪模式和非贪婪模式

* 贪婪模式 是尽可能多的匹配
	* `‘12345678’.replacr(/\d{3,6}/g,'X')` 的结果是`X78`	
* 非贪婪模式是尽可能少的匹配
	*  `‘12345678’.replacr(/\d{3,6}？/g,'X')` 的结果是`XX78`
* 如何使用非贪婪模式？
	* 在量词后面添加`？ `  

## JS中的正则对象有什么属性？

* `global` 是否全文搜索 ，默认为false 	，只读
* `ignoreCase` 是否大小写敏感 ，默认为false ，只读
* `multiline` 多行搜索 默认为false，只读
* `lastIndex` 是当前表达式匹内容的最后一个字符的下一个位置，非全局模式会该值不改变，一直为0
* `source` 正则表达式的文本字符串

## JS中正则表达API?
*  reg对象
	*  test：测试字符串是否存在匹配的字符串
	*  exec：对字符串执行搜索，并且更新全局RexExp对象的属性，没有匹配的文本返回null，否则返回一个结果数组
		* 结果数组有两个额外属性 index 和 input
		* index：匹配文本的第一个字符的位置 
		* input：存放被检索的字符串
		* 数组的第一个元素是匹配的文本，第二个元素是第一个子表达式，即分组，以此类推  
*  string对象
	* search：返回第一个匹配子串的起始位置，如果找不到，则返回-1
		* 不支持全局搜索，会主动忽略修饰符g
		* 如果参数不是正则表达式，会通过RegExp构造函数转换其为正则表达式 
	* match 
		* 带有修饰符g，返回的数组包含字符串中所有匹配的结果
		* 不带有修饰符g，返回的数组第一个元素是匹配的子串，余下元素是子表达式
		* 不带有修饰符g，match效果和exec效果是一致的，返回的数组都带有index和input属性
	* replace：执行检索和替换操作
		* 有修饰符g，将替换源字符中匹配的所有子串；没有修饰符g，只替换匹配的第一个子串
		* 若第一个参数不是正则，则replace()会直接搜索这个字符串，而不是通过RegExp转换为正则
		* 替换字符传出现$加数字，则与指定的子表达式相匹配的文本替换这两个字符
	* split：参数也可以是正则，效果很强大哦😆

## 正则中预定义类
*   `.` 等价于` [^\r\n]` 除回车符和换行符之外的所有字符
*   `\d` 等价于 `[0-9]` 数字字符
*  ` \D` 等价于 `[^0-9]` 非数字字符
*   `\s` 等价于 `[\t\n\x0B\f\r]` 空白符
*   `\S` 等价于 `[^\t\n\x0B\f\r]` 非空白符
*   `\w` 等价于 `[a-zA-Z_0-9]` 单词字符（数字、字母、下划线）
*   `\W` 等价于 `[^a-zA-Z_0-9]` 非单子字符

## 量词
* `？` 零次或者一次
* `+` 一次或者多次
* `*` 零次或者多次
* `{n}` 出现n次
* `{n,m}` 出现n到m次
* `{n,}` 至少出现n次

## 分组
* `'2018/4/3'.replace(/(\d{4})\/(\d{1,2})\/(\d{1,2})/g, '$1-$2-$3')`
	* 原字符串替换为2018/4/3 
	* 上述正则是转换了日期格式
*  `'25/11/2018'.replace(/(?:\d{1,2})\/(\d{1,2})\/(\d{4})/g, '$2-$1')`
	* 原字符串替换为2018-11 
	* `(?:\d{1,2})` 为第一个分组，但是添加了`?:`,即忽略该分组