## 贪婪模式和非贪婪模式

* 贪婪模式 是尽可能多的匹配
	* `‘12345678’.replacr(/\d{3,6}/g,'X')` 的结果是`X78`	
* 非贪婪模式是尽可能少的匹配
	*  `‘12345678’.replacr(/\d{3,6}？/g,'X')` 的结果是`XX78`
* 如何使用非贪婪模式？
	* 在量词后面添加`？ `  

## JS中的正则对象有什么属性？

* `global` 是否全文搜索 ，默认为false 	，只读
* `ignoreCase` 是否大小写敏感 ，默认为false ，只读
* `multiline` 多行搜索 默认为false，只读
* `lastIndex` 有修饰符g，表示整个字符串中下次检索的位置，非全局模式会该值不改变，一直为0
* `source` 正则表达式的文本字符串，只读

## JS中正则表达API?
*  正则对象
	*  test：测试字符串是否存在匹配的字符串
	*  exec：对字符串进行匹配检索，若未找到，返回null；若找到返回数组，并且带有input和index值
		* index是包含了发生匹配的字符位置
		* input是引用正在检索的字符 
		* 返回的数组第一个元素是匹配的子串，余下元素是子表达式
		* 带有修饰符g时，将当前正则对象的lastIndex属性设置为紧挨着匹配子串的字符位置。当同一个正则表达式第二次调用exec()时，它将从lastIndex属性所指示的字符出开始检索。如果exec()没有发现匹配结果，将会设置lastIndex为0 
*  string对象
	* search：返回第一个匹配子串的起始位置，如果找不到，则返回-1
		* 不支持全局搜索，会主动忽略修饰符g
		* 如果参数不是正则表达式，会通过RegExp构造函数转换其为正则表达式 
	* match 
		* 带有修饰符g，返回的数组包含字符串中所有匹配的结果
		* 不带有修饰符g，返回的数组第一个元素是匹配的子串，余下元素是子表达式
		* 不带有修饰符g，match效果和exec效果是一致的，返回的数组都带有index和input属性
	* replace：执行检索和替换操作
		* 有修饰符g，将替换源字符中匹配的所有子串；没有修饰符g，只替换匹配的第一个子串
		* 若第一个参数不是正则，则replace()会直接搜索这个字符串，而不是通过RegExp转换为正则
		* 替换字符传出现$加数字，则与指定的子表达式相匹配的文本替换这两个字符
	* split：参数也可以是正则，效果很强大哦😆

## 正则中预定义类
*   `.` 等价于` [^\r\n]` 除回车符和换行符之外的所有字符
*   `\d` 等价于 `[0-9]` 数字字符
*  ` \D` 等价于 `[^0-9]` 非数字字符
*   `\s` 等价于 `[\t\n\x0B\f\r]` 空白符
*   `\S` 等价于 `[^\t\n\x0B\f\r]` 非空白符
*   `\w` 等价于 `[a-zA-Z_0-9]` 单词字符（数字、字母、下划线）
*   `\W` 等价于 `[^a-zA-Z_0-9]` 非单子字符

## 量词
* `？` 零次或者一次
* `+` 一次或者多次
* `*` 零次或者多次
* `{n}` 出现n次
* `{n,m}` 出现n到m次
* `{n,}` 至少出现n次

## 分组
* `'2018/4/3'.replace(/(\d{4})\/(\d{1,2})\/(\d{1,2})/g, '$1-$2-$3')`
	* 原字符串替换为2018/4/3 
	* 上述正则是转换了日期格式
*  `'25/11/2018'.replace(/(?:\d{1,2})\/(\d{1,2})\/(\d{4})/g, '$2-$1')`
	* 原字符串替换为2018-11 
	* `(?:\d{1,2})` 为第一个分组，但是添加了`?:`,即忽略该分组